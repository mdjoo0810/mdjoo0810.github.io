---
title: AWS SQS, Deep Dive
author: 코드돈
date: 2025-03-10 10:00:00 +0900
categories: [개발, Infra]
tags: [aws, sqs, messaging]
---

# 시작하며

최근 회사에서 알림 서비스 재구축 프로젝트를 진행하게 됐습니다. 
기존의 알림 시스템은 알림 API 서버가 직접 제3자 알림 서비스 제공 업체의 API를 호출하고 응답을 받아 실시간으로 처리하는 방식이었습니다.

겉으로 보기엔 단순한 구조였지만, 트래픽이 증가할수록 다양한 문제가 나타났습니다. 특히 요청이 집중될 때는 Rate Limit(요청 속도 제한)을 안정적으로 처리하기 어려웠고, 발송이 실패했을 때 응답을 기다리는 클라이언트가 있기 때문에 안정적인 재처리(retry) 로직을 구현하기도 쉽지 않았습니다. 게다가 즉각적으로 실시간 응답이 필요한 구조였기 때문에 서비스의 안정성을 유지하는 데도 큰 부담이 되었습니다.

이러한 문제를 해결하기 위해 저희는 알림 발송 과정을 비동기적으로 처리할 수 있도록 메시지 큐(Message Queue, MQ)를 도입하기로 결정했습니다.

MQ를 도입하기로 한 이후에도 선택지는 다양했습니다. 이미 팀에서는 AWS의 AmazonMQ를 통해 RabbitMQ를 사용하고 있었고, 상황에 따라 Kafka 같은 옵션도 충분히 고려할 수 있었습니다.

하지만 AWS의 SQS(Simple Queue Service)를 선택한 이유는 명확했습니다. 각 메시징 시스템마다 고유한 장단점이 있지만, 저희 팀은 메시징 인프라의 운영이나 유지보수보다는 비즈니스 로직 개발에 집중하고 싶었습니다. 특히 Kafka 클러스터는 높은 관리 비용이 필요한데, 이는 현재 저희 서비스의 트래픽 규모와 맞지 않았습니다. 또한 기존에 사용 중이던 RabbitMQ는 별도의 분리된 환경에 구성되어 있어 클라우드 기반으로 관리한다 하더라도 일정 부분 관리 부담이 존재했습니다.

그래서 상대적으로 가볍고 관리가 편리한 AWS SQS를 선택하게 되었습니다. 물론 기존에도 큐의 개념과 필요성에 대해서는 어느 정도 알고 있었지만, 실제 AWS 환경에서 SQS를 도입해 운영하는 것은 이번이 처음이었습니다.

이 글에서는 제가 AWS SQS를 학습했던 내용을 기록하고자 합니다.

# AWS SQS Deep Dive

우선 SQS 가 무엇인지 알아보겠습니다.
SQS의 정의를 찾아보면 다음과 같습니다.

> Amazon SQS는 서버리스 메시지 큐 서비스로, 분산 시스템과 마이크로서비스를 효과적으로 분리하여 독립적인 비동기 통신을 가능하게 합니다. 서버리스이기 때문에 사용자는 인프라를 관리할 필요가 없고, 손쉽게 확장 가능합니다.

**SQS가 필요한 이유**

SQS 뿐아니라 MQ 시스템을 사용하는 이유로도 표현할 수 있을 것 같은데요.

대표적으로 아래와 같은 상황에 사용되게 됩니다.

- 서비스 간 강한 결합 문제 해결
  - A 서비스가 B 서비스의 API 를 직접 호출하게되면 B 서비스가 다운될 경우 전체 시스템이 영향을 받을 수 있음.
  - SQS 를 사용하면 A 서비스가 메시지에 큐를 넣고 B 서비스가 나중에 꺼내 처리하므로 비동기 통신 구조로 서비스 결합도를 줄일 수 있습니다.
- 트래픽 급증 대응
  - 특정 시간에 요청이 매우 증가하는 경우, API 서버는 요청을 처리하지 못하고 장애가 발생할 수 있습니다.
  - SQS 로는 큐를 버퍼 역할로 사용하여 트래픽을 분산할 수 있습니다.
- 비동기 데이터 처리
  - 대량의 데이터를 처리할 때, 모든 작업을 즉시 실행하는 것이 아니라 SQS 에 넣어놓고 순차적으로 처리하면 효율적입니다.
  - 예시로는 사용자 업로드 이미지 변환, 데이터 백업등의 작업을 SQS 로 분산할 수 있습니다.


## 표준 큐 (Standard Queue)
AWS SQS(Standard Queue)는 마이크로서비스 아키텍처에서 이벤트 기반 비동기 통신을 구현하는 데 가장 널리 사용되는 큐 서비스입니다.
이 큐를 사용하면 서비스 간의 결합도를 낮추고(Decoupling), 고가용성(High Availability)을 확보하며, 확장성(Scalability)이 뛰어난 메시징 시스템을 구축할 수 있습니다.

### 특징
1. 최소 1회 이상(At-least-once) 메시지 전송 보장
	- SQS는 메시지를 최소 한 번 이상 전달하지만, 일부 경우 같은 메시지가 여러 번 전달될 수 있습니다.
	- 따라서 컨슈머(Consumer)는 중복 메시지를 처리할 수 있도록 Idempotency(멱등성)를 보장해야 합니다.
2. 메시지 순서 보장되지 않음(Best-Effort Ordering)
    - Standard Queue는 메시지가 순차적으로 처리될 것을 보장하지 않으며, 네트워크 상태 및 큐 내부의 부하에 따라 메시지의 순서가 달라질 수 있습니다.
    - 만약 메시지 순서가 중요한 경우, FIFO Queue를 사용해야 합니다.
3. 거의 무제한 처리량 지원
	- 초당 API 요청(Call)의 개수 제한이 없으며, 많은 수의 메시지를 동시에 처리할 수 있습니다.

### 동작 방식
![alt text](/assets/img/posts/2025-03-10-dev-aws-sqs-deep-dive/image.png)

SQS Standard Queue의 기본 동작은 다음과 같습니다.
1. **생산자(Producer)** 가 SQS 큐로 메시지를 전송합니다.
2. **큐(Queue)** 는 메시지를 보관하고, 여러 개의 소비자(Consumer)들이 이 메시지를 폴링(Polling) 방식으로 가져갑니다.
3. **소비자(Consumer)** 가 메시지를 가져가면, 메시지는 일시적으로 숨겨집니다(Visibility Timeout).
4. 소비자가 메시지를 정상적으로 처리하면 **큐에서 메시지를 삭제(DeleteMessage 호출)** 하여 중복 처리를 방지합니다.
5. 만약 소비자가 메시지를 처리하지 못하거나 오류가 발생하면, 메시지는 다시 큐에서 보이게 되어 다른 소비자가 가져가게 됩니다.

이러한 동작 방식 덕분에 SQS는 메시지를 안정적으로 전달할 수 있습니다. 다만, 중복 전송이 발생할 수 있기 때문에 소비자는 반드시 멱등성(Idempotency)을 고려하여 메시지를 처리해야 합니다.

### 메시지 중복과 해결 방법

SQS Standard Queue는 At-least-once Delivery(최소 1회 전달) 원칙을 따릅니다.
즉, 같은 메시지가 여러 번 전송될 수 있으며, 이는 AWS의 메시지 저장 방식과 장애 처리 프로세스 때문입니다.

#### 메시지 중복이 발생하는 원인
- 메시지를 저장하는 다중 가용 영역(Multi-AZ) 아키텍처에서 한 데이터센터가 일시적으로 다운되었을 때, 다른 가용 영역의 복제본이 사용될 수 있습니다. 이 과정에서 메시지가 중복 전송될 수 있습니다.
- 소비자가 메시지를 받아간 후 삭제 요청(DeleteMessage 호출)을 보내기 전에 네트워크 장애가 발생하면, SQS는 해당 메시지가 소비되지 않았다고 판단하고 다시 제공할 수 있습니다.

#### 중복 메시지 문제를 해결하는 방법
1. 애플리케이션에서 중복 감지 로직을 구현
   - 메시지 본문에서 고유한 ID(예: 주문 번호, 트랜잭션 ID)를 포함하고, 데이터베이스 또는 캐시(Redis, DynamoDB 등)에 이를 저장하여 중복 여부를 확인합니다.
2. 소비자에서 멱등성(Idempotency)을 보장하는 방식으로 처리
    - 같은 메시지가 여러 번 도착하더라도 동일한 결과를 반환하도록 로직을 작성합니다. 예를 들어, “이미 처리된 주문이면 추가 작업을 하지 않는다”는 방식이 될 수 있습니다.
3. FIFO Queue를 사용하는 것도 대안이 될 수 있음
	- 메시지 순서와 중복 방지가 중요한 경우, FIFO Queue를 사용하면 이러한 문제를 해결할 수 있습니다.

### 메시지 순서의 특성과 해결방법

SQS Standard Queue에서는 메시지가 발송된 순서와 다르게 도착할 수 있습니다.
이러한 특성은 메시지가 여러 가용 영역으로 복제되는 과정에서 발생합니다.
즉, 메시지 A → B → C 순서로 큐에 넣더라도,
소비자가 이를 가져갈 때는 B → C → A 순서가 될 수도 있습니다.

#### 순서가 중요한 경우 해결 방법
1. 각 메시지에 타임스탬프를 추가하여, 소비자에서 메시지 순서를 정렬
	- 예를 들어, 주문 상태를 업데이트하는 경우 “결제 완료” 메시지가 “주문 확인”보다 먼저 처리되지 않도록 타임스탬프를 기반으로 정렬할 수 있습니다.
	- 결국 메시지 삭제처리를 해야하기 떄문에 메시지를 삭제처리하지 않으면 대기열에 머무르는 현상을 이용한 것 입니다.
    	- 다만 이렇게되면 대기열의 크기가 무한정 커질 수 있는 단점이 있습니다.
2. FIFO Queue를 사용하여 순서를 보장
	- 만약 메시지 순서가 반드시 유지되어야 한다면, Standard Queue 대신 FIFO Queue를 사용하는 것이 적절합니다.

### 처리량과 성능

AWS에 따르면 SQS Standard Queue는 사실상 무제한 처리량(Unlimited Throughput)을 지원합니다.
(`SendMessage`, `ReceiveMessage`, `DeleteMessage`)

### 동시성

SQS Standard Queue를 운영할 때 중요한 부분 중 하나가 동시성(Concurrency) 설정입니다.
잘못된 동시성 설정을 적용하면 컨슈머(Consumer)들이 동일한 메시지를 경쟁적으로 가져가거나, 처리량이 급격히 증가하여 과부하가 발생하는 문제가 생길 수 있습니다.

#### 동시성을 고려해야 하는 이유

SQS Standard Queue는 기본적으로 메시지가 중복으로 소비될 수 있는 구조를 가지고 있기 때문에,
동시성을 제대로 조절하지 않으면 하나의 메시지를 여러 개의 컨슈머가 동시에 가져가는 문제가 발생할 수 있습니다.
이를 방지하려면 다음과 같은 요소들을 고려하여 동시성 조절을 해야 합니다.

#### 동시성 조절 방법

다중 컨슈머 환경에서 SQS의 동시성을 조절하는 방법에는 여러 가지가 있습니다.

1. 멀티 스레드 및 병렬 처리 활용
    - SQS 컨슈머를 다중으로 실행하는 경우, 멀티 스레드를 활용하여 병렬로 메시지를 처리할 수 있습니다. 이렇게 하면 SQS에서 여러 개의 메시지를 동시에 가져와 더 빠르게 처리할 수 있습니다.
    - 만약 한 번에 10개의 메시지를 가져와야 한다면, 10개의 개별 스레드가 각각 메시지를 처리하도록 설정할 수 있습니다.
	- 다만, 너무 많은 스레드를 실행하면 CPU 및 네트워크 리소스가 과부하될 가능성이 있으므로 적절한 스레드 풀 크기를 설정하는 것이 중요합니다.

2. 배치 크기(Batch Size) 조절
   - SQS Standard Queue는 한 번의 API 호출에서 여러 개의 메시지를 가져와 처리할 수 있도록 배치(Batch) 처리를 지원합니다. 배치 크기를 조절하면 네트워크 요청 수를 줄여 성능을 최적화할 수 있습니다.
   - 예를 들어, Batch Size = 10으로 설정하면 한 번의 요청에서 최대 10개의 메시지를 가져와 처리할 수 있습니다.이렇게 하면 SQS의 API 호출 비용을 줄이고, 메시지 처리 속도를 증가시키는 효과가 있습니다.
   - 배치 크기를 설정할 때 고려해야 할 점은 다음과 같습니다.
        - 배치 크기가 너무 크면 한 번에 많은 메시지를 가져오지만, 개별 메시지의 처리 시간이 길어질 수 있습니다.
   	    - 배치 크기가 너무 작으면 네트워크 요청이 증가하여 API 비용이 높아지고, 불필요한 오버헤드가 발생할 수 있습니다.

3. 배치 윈도우(Batch Window) 설정
   - 배치 윈도우는 지정된 시간 동안 메시지를 모아서 한 번에 처리할지 여부를 결정합니다.
   - 만약 배치 크기(Batch Size)를 10으로 설정하고, Batch Window를 5초로 설정하면, 최대 10개의 메시지를 모아서 가져오되, 5초 안에 10개가 모이지 않으면 모인 개수만큼 가져와 처리하게 됩니다.
   - 이러한 방식은 짧은 시간 내에 많은 메시지가 도착하는 경우에는 유용하지만, 트래픽이 낮은 경우에는 불필요한 대기 시간이 발생할 수 있습니다. 따라서, 트래픽 패턴에 맞게 적절히 조정해야 합니다.

### 제한사항

- 메시지 순서 보장 불가 → Best-effort Ordering 방식이므로, 순서가 중요한 경우에는 FIFO Queue 사용 고려
- 중복 메시지 가능성 → At-least-once Delivery 방식이므로, 중복 감지를 위한 추가 로직 필요
- In-flight 메시지 제한 → 최대 120,000개
- 지연 메시지(Delay Queue) 설정 가능 → 최대 15분까지 메시지 소비 지연 가능

## FIFO Queue

**SQS FIFO(First-In-First-Out) Queue는 메시지 순서가 중요한 시스템을 위해 설계된 큐** 타입입니다.
이 큐는 메시지의 **순서를 유지** 하면서도 **정확히 한 번(Exactly-Once Processing)** 만 처리되도록 보장합니다.
따라서 결제 처리, 주문 관리, 금융 거래 등 순서가 중요한 시스템에서 필수적으로 사용됩니다.

### 특징 

1. 순서 보장 (First-In-First-Out Delivery)
	- Standard Queue와 달리 FIFO Queue는 메시지가 들어온 순서대로 처리됨을 보장합니다.
	- 같은 **메시지 그룹(Message Group ID)** 에 속하는 메시지는 순서를 유지하며 소비됩니다.
2. 중복 방지 (Exactly-Once Processing)
	- 메시지는 큐에 한 번만 저장되고 중복으로 소비되지 않습니다.
	- Deduplication ID를 사용하여 5분 내 동일한 메시지를 중복 처리하지 않도록 자동 감지합니다.
3. 제한된 처리량 (Throughput 제한)
	- 기본적으로 초당 300개의 API 요청(메시지 전송, 수신, 삭제)을 지원합니다.
	- **배치 모드(Batching)** 를 활용하면 최대 3,000개의 메시지를 처리할 수 있습니다.
	- High Throughput FIFO Queue를 활성화하면 더 높은 처리량을 지원합니다.

### 동작 방식

![alt text](/assets/img/posts/2025-03-10-dev-aws-sqs-deep-dive/image-1.png)

FIFO Queue는 Standard Queue와 달리 파티션(Partition) 개념을 사용하여 메시지를 저장하고 관리합니다.
AWS는 **메시지 그룹 ID(Message Group ID)** 를 기준으로 내부적으로 메시지를 특정 파티션에 저장합니다.

#### 메시지 라우팅
- 메시지가 FIFO Queue에 추가되면 **Message Group ID를 해싱** 하여 특정 파티션에 저장됩니다.
- 동일한 Message Group ID를 가진 메시지는 같은 파티션에서 순차적으로 처리됩니다.
- 서로 다른 Message Group ID를 가진 메시지는 다른 파티션에 저장되므로 병렬 처리 가능합니다.

#### 예시
온라인 쇼핑몰에서 주문 데이터를 처리하는 경우,

- Message Group ID = `User1` 인 메시지는 같은 파티션에서 순서대로 처리됩니다.
- Message Group ID = `User2` 인 메시지는 다른 파티션에서 독립적으로 처리될 수 있습니다.

### 메시지 중복 방지

FIFO Queue는 중복 메시지를 자동으로 감지하고 제거하는 기능을 제공합니다.
중복 방지 기능은 5분 동안 동일한 메시지가 여러 번 전송되는 것을 방지합니다.

#### 중복 방지 방식
AWS는 중복 감지를 위해 두 가지 방식을 제공합니다.

1. Content-Based Deduplication (내용 기반 중복 방지)
	- 메시지 본문의 내용을 기반으로 SHA-256 해시값을 생성하여 Deduplication ID로 사용합니다.
	- 동일한 메시지 본문이 5분 내 재전송되면 큐에서 중복으로 처리되지 않음을 보장합니다.
2.	Explicit Deduplication ID (명시적 중복 방지 ID 지정)
	- 프로듀서(Producer)가 직접 Deduplication ID 값을 지정하여 메시지를 중복 방지할 수 있습니다.
	- 예를 들어, 주문 ID(Order-1234)를 Deduplication ID로 설정하면 5분 내 동일한 주문 메시지가 중복 처리되지 않습니다.

``` json
{
  "MessageBody": "Order details Order-1234",
  "MessageGroupId": "User1",
  "MessageDeduplicationId": "Order-1234"
}
```

위와 같이 MessageDeduplicationId = `Order-1234`를 설정하면 5분 동안 동일한 메시지가 다시 전송되지 않도록 보장합니다.

이외에도 중복 제거 범위를 지정할 수 있습니다.
1. 대기열 수준: 중복제거가 GroupID에 관계없이 대기열의 모든 메시지에 적용되며, High Throughput FIFO Queue 에서는 사용할 수 없습니다.
2. 메시지 그룹 수준: Message Group ID 내에서 중복 제거되며, High Throughput FIFO Queue 의 기본 옵션입니다.

### 메시지 순서 보장

FIFO Queue는 큐 단위가 아닌 Message Group ID 단위로 순서를 보장합니다.
즉, 동일한 Message Group ID를 가진 메시지는 순서대로 소비되지만, 다른 그룹의 메시지는 독립적으로 처리될 수 있습니다.


#### 예시
```
1.	Message Group ID = User1: 메시지 A1 → A2 → A3 (이 순서대로 처리됨)
2.	Message Group ID = User4: 메시지 B1 → B2 → B3 (독립적으로 처리됨)
```
즉, 같은 사용자(User123) 내에서는 메시지가 순서대로 처리되지만, 다른 사용자(User456)의 메시지는 병렬로 처리될 수 있습니다.

### 성능 및 처리량

FIFO Queue는 Standard Queue보다 처리량이 제한적이지만,
배치 모드 및 High Throughput FIFO Queue를 활용하면 성능을 최적화할 수 있습니다.

1) 기본 처리량 제한
	- 기본 설정: 초당 최대 300개의 API 호출 가능
	- 배치 모드 활성화 시: 초당 3,000개 메시지 처리 가능
	- High Throughput 활성화 시: 초당 최대 60,000개 메시지 처리 가능

2) High Throughput FIFO Queue 설정

기본 FIFO Queue는 처리량이 제한적이므로,
더 높은 성능이 필요한 경우 High Throughput FIFO Queue를 활성화하면 됩니다.

이 또한 대기 수준, 메시지 그룹 수준("고처리량 FIFO 대기열" 에 사용됨) 두 가지 수준에서 처리량을 지정할 수 있습니다.

### 제한사항

- 메시지 지연(Delay Queue) 제한
	- 최소 지연 시간: 0초 (즉시 전달)
	- 최대 지연 시간: 15분 (900초)
	- 특정 그룹의 메시지가 지연되면, 해당 그룹의 모든 메시지가 함께 지연될 수 있음
- 롱 폴링(Long Polling) 대기 시간 제한
	- 최대 롱 폴링 대기 시간: 20초
	- 메시지가 없을 경우 즉시 응답하지만, 롱 폴링을 사용하면 최대 20초 동안 대기 후 응답
- 메시지 그룹 수 제한 없음
	- FIFO Queue에서는 메시지 그룹의 개수에 대한 제한이 없음
- 큐의 메시지 저장 한도
	- SQS FIFO Queue는 저장 가능한 메시지 개수에 제한이 없음
- In-flight 메시지 제한
	- FIFO Queue에서 최대 20,000개의 In-flight 메시지를 허용
	- In-flight 상태: 소비자가 메시지를 가져갔으나 아직 삭제되지 않은 상태
	- 제한 초과 시 추가 메시지는 반환되지 않으며, 오류 메시지 없이 대기

## High Throughput FIFO Queue

FIFO 큐는 기본적으로 메시지 순서를 유지하면서 정확히 한 번(Exactly-once)만 메시지를 처리하도록 설계되어 있습니다. 그러나 표준 FIFO 큐의 경우 초당 최대 300개의 API 호출(배치 사용 시 3,000개 메시지)로 제한되기 때문에 높은 처리량이 필요한 환경에서는 한계를 가질 수 있습니다. 이를 해결하기 위해 High Throughput FIFO Queue 옵션이 제공됩니다.

이 기능을 활성화하면 SQS는 메시지 그룹 단위로 데이터를 분할하여 병렬로 처리할 수 있도록 최적화됩니다. 즉, FIFO의 메시지 순서를 유지하면서도 성능과 확장성을 극대화할 수 있도록 동작합니다.

### 처리량

SQS High Throughput FIFO Queue의 처리량은 지역에 따라 차이가 있습니다.

- 일반적으로 초당 최대 6,000개 API 호출을 지원하지만,
- 배치를 활용하면 60,000개 이상의 메시지 처리가 가능합니다.

[지역 별 처리량 (AWS)](https://docs.aws.amazon.com/ko_kr/general/latest/gr/sqs-service.html#limits_sqs.html) 자세한 내용은 링크를 참고해주세요.


## AWS SQS 설정 

지금까지 Amazon SQS의 주요 개념과 큐 유형에 대해 살펴보았습니다. 이제 SQS의 공통 설정(Configuration) 요소에 대해 자세히 알아보겠습니다.

이 설정들은 Standard Queue와 FIFO Queue 모두에 적용될 수 있습니다.

### Visibility Timeout

Visibility Timeout은 메시지가 컨슈머에게 전달된 이후 일정 기간 동안 다른 컨슈머에게 보이지 않도록 설정하는 시간입니다.

예를 들어, 하나의 컨슈머가 메시지를 받아 처리하는데 30초가 걸린다고 가정해 보겠습니다. Visibility Timeout을 30초로 설정하면, 다른 컨슈머가 동일한 메시지를 가져가지 않도록 보장할 수 있습니다.

만약 Visibility Timeout이 너무 짧다면?
- 컨슈머가 메시지를 완전히 처리하기 전에 다른 컨슈머가 동일한 메시지를 가져갈 가능성이 생깁니다.
- 이렇게 되면 메시지가 중복으로 처리될 위험이 있으며, 이로 인해 데이터 정합성이 깨질 수 있습니다.

반대로 Visibility Timeout이 너무 길다면?
- 컨슈머가 처리에 실패했을 때, 다른 컨슈머가 해당 메시지를 다시 가져가는 시간이 늦어지므로 재처리 속도가 저하됩니다.

#### 적절한 Visibility Timeout 설정의 예시
- 단순한 데이터 처리 (예: 로그 기록, 이벤트 로깅) → 5~10초
- 데이터베이스 업데이트, 결제 처리와 같은 크리티컬한 작업 → 30초 이상
- 비디오 렌더링, 머신 러닝 작업과 같이 긴 시간이 필요한 프로세스 → 5~10분

### Delivery Delay 

SQS의 Delivery Delay는 메시지가 큐에 추가된 후 컨슈머에게 노출되기까지의 지연 시간을 설정하는 옵션입니다.

예를 들어, 메시지가 큐에 추가된 직후 바로 처리되는 것이 아니라 일정 시간이 지난 후에야 처리되도록 하고 싶을 때 사용할 수 있습니다.

- 기본(최소) 지연 시간: 0초
- 최대 지연 시간: 15분

사용 사례
1. 비즈니스 로직에서 특정 시간 후에 실행이 필요한 경우
   - 예를 들어, 사용자에게 10분 후 알림을 보내야 하는 경우 Delivery Delay를 10분으로 설정하면 됩니다.
2. 한 시스템에서 생성된 이벤트가 즉시 처리되지 않도록 보호할 때
   - 예를 들어, 백엔드에서 고객 주문을 처리하기 전 일정 시간 후에 검증 단계가 수행되도록 설정할 수 있습니다.
3. 오토스케일링과 함께 활용
   - 트래픽이 급증하는 상황에서 즉시 처리하지 않고, 2~3분 동안 대기하도록 설정하여 부하를 분산할 수도 있습니다.

#### FIFO Queue와 Standard Queue에서의 차이점
- Standard Queue에서는 새로운 설정을 적용해도 이미 큐에 있는 메시지에는 적용되지 않습니다.
- FIFO Queue에서는 설정 변경 시 기존 메시지에도 영향을 미칩니다.

**왜 이런 차이가 날까?**

FIFO Queue와 Standard Queue가 설정 변경 시 기존 메시지에 미치는 영향이 다른 이유는 메시지 처리 방식과 저장 구조의 차이 때문입니다.

1. Standard Queue는 비결정론적 메시지 전달 방식
   - 메시지를 여러 서버에 복제하고, 가장 빠른 서버에서 제공하기 때문에 순서가 보장되지 않음.
   - 설정 변경 후에도 기존 메시지는 기존 방식대로 처리되며, 새로운 설정은 이후 들어오는 메시지에만 적용됨.
2. FIFO Queue는 순서 보장 및 정확한 메시지 전달을 유지해야 함
   - 특정 파티션에 메시지를 저장하며 순서를 유지하기 위해 큐 전체에서 설정을 반영해야 함.
   - 설정 변경 시 기존 메시지에도 새로운 설정이 적용됨.


### Receive Message Wait Time

Receive Message Wait Time은 컨슈머가 메시지를 요청할 때, 메시지가 없을 경우 얼마나 대기할지를 설정하는 값입니다.

이 설정은 크게 두 가지 방식으로 나뉩니다.

1. Short Polling (짧은 폴링, 기본 설정)
    - 컨슈머가 메시지를 요청하면 즉시 응답합니다.
    - 메시지가 없을 경우 빈 응답을 반환합니다.
    - 응답 속도는 빠르지만, 불필요한 API 호출이 많아질 수 있어 비용이 증가할 수 있습니다.
2. Long Polling (긴 폴링, 최대 20초까지 가능)
    - 컨슈머가 메시지를 요청할 때, 지정된 시간 동안 큐에 메시지가 추가되기를 기다립니다.
    - 메시지가 생기면 즉시 반환하며, 메시지가 없으면 대기 시간이 끝날 때까지 기다린 후 응답합니다.
    - 불필요한 API 요청을 줄여 비용을 절감할 수 있으며, 서버 부담을 최소화할 수 있습니다.

#### Short Polling vs Long Polling 예제
- 짧은 폴링(Short Polling):
  - 컨슈머가 1초마다 메시지를 요청한다면, 메시지가 없어도 계속 API 요청이 발생하여 불필요한 비용이 발생합니다.
- 긴 폴링(Long Polling):
    - 컨슈머가 20초 동안 대기하면서 메시지를 요청하면, 메시지가 없는 경우 불필요한 요청을 방지하고, 새로운 메시지가 오면 즉시 응답할 수 있습니다.

#### 실제 사용 사례
- Short Polling
  - 응답 시간이 중요한 실시간 애플리케이션 (예: 금융 거래, 채팅 서비스)
- Long Polling
  - 비용 절감이 중요한 백엔드 배치 시스템, 비동기 처리 시스템

### Message Retention Period

SQS는 큐에 저장된 메시지를 일정 기간 동안 유지할 수 있으며, 이 값을 Message Retention Period라고 합니다.
- 기본 보관 기간: 4일
- 최소 설정 가능 값: 1분
- 최대 설정 가능 값: 14일

메시지가 보관 기간을 초과하면 자동으로 삭제됩니다.
이 설정은 큐에 적체된 메시지가 일정 기간 유지될 필요가 있는 경우 적절한 값으로 조정해야 합니다.

### Maximum Message Size

SQS에서 허용하는 메시지 크기 제한은 다음과 같습니다.
- 기본 최대 메시지 크기: 256KB
- 최소 메시지 크기: 1Byte

메시지가 256KB를 초과할 경우, **Amazon S3와 연계하여 메시지를 저장하고 참조하는 방법(Claim-Check Pattern)** 을 사용할 수 있습니다.

#### Claim-Check Pattern
![alt text](/assets/img/posts/2025-03-10-dev-aws-sqs-deep-dive/image-2.png)

#### 사용 사례
- 텍스트 기반의 간단한 로그 메시지 처리
- 대부분의 로그 메시지는 256KB 이내로 충분합니다.
- 대용량 데이터 처리
- 이미지, 동영상, JSON 데이터 등 대량의 데이터를 처리하려면 S3를 활용하여 메시지의 URL만 큐에 저장하는 방식을 사용해야 합니다.


## AWS SQS 암호화

AWS에서 보안은 필수 요소이며, SQS에서도 데이터를 보호하기 위해 암호화 기능을 제공합니다. 암호화는 크게 **전송 중 암호화(Encryption in Transit)** 와 **저장 시 암호화(Encryption at Rest)** 로 나눌 수 있습니다.

1. 전송 중 암호화(Encryption in Transit)
    - 기본적으로 모든 SQS 메시지는 TLS(Transport Layer Security)를 사용하여 암호화됩니다.
    - 사용자가 별도로 설정할 필요 없이 자동으로 적용되며, 네트워크 상에서 데이터가 보호됩니다.
2. 저장 시 암호화(Encryption at Rest)
    - SQS에 저장된 메시지를 암호화할지 선택할 수 있으며, 암호화를 활성화하면 추가 비용이 발생할 수 있습니다.
    - 저장된 데이터가 암호화되면, 승인된 사용자 및 서비스만 데이터를 해독할 수 있습니다.

### SQS 저장 암호화 옵션

SQS에서는 저장 암호화를 위한 두 가지 방식을 제공합니다.

1. SQS 관리형 키(SSE-SQS)
   - AWS가 자동으로 암호화 키를 생성 및 관리하므로 사용자는 추가 설정 없이 암호화를 사용할 수 있습니다.
   - 별도의 키 관리가 필요하지 않으며, AWS에서 암호화 및 복호화를 처리합니다.
2. KMS(Key Management Service) 기반 암호화(SSE-KMS)
   - 사용자가 직접 AWS KMS를 활용해 키를 생성, 관리 및 회전(rotation)할 수 있는 옵션입니다.
   - 보다 세부적인 접근 제어 및 키 관리 정책을 설정할 수 있어 보안 요구사항이 높은 환경에 적합합니다.
   - 하지만, KMS 요청당 추가 비용이 발생할 수 있습니다.

#### 선택 기준
- 보안이 중요한 환경에서 SQS를 사용할 경우, SSE-KMS를 활용한 암호화가 적합합니다.
- 반면, 별도의 관리 부담 없이 기본적인 보안 수준을 유지하려면 SSE-SQS를 사용하는 것이 효율적입니다.

## SQS Dead-Letter Queue (DLQ)

SQS에서 **Dead-Letter Queue(DLQ)** 는 메시지 처리에 실패한 경우 이를 별도로 저장하는 기능을 제공합니다. 이 기능은 원본 큐에서 지속적으로 실패하는 메시지들이 무한히 쌓이는 것을 방지하고, 문제의 원인을 분석할 수 있도록 도와줍니다.

### DLQ의 역할과 필요성

SQS의 메시지는 일반적으로 정상적인 흐름에 따라 프로듀서(Producer)가 생성한 후 컨슈머(Consumer)에 의해 소비됩니다. 하지만 다양한 이유로 메시지가 처리되지 못하고 남아있을 수 있습니다.

예를 들어, 다음과 같은 상황이 발생할 수 있습니다.
1.	잘못된 메시지 형식
    - 메시지의 데이터가 손상되었거나 예상된 포맷과 다를 경우, 컨슈머가 정상적으로 처리할 수 없습니다.
    - 하드웨어 장애, 네트워크 오류 등으로 인해 데이터가 변형될 가능성이 있습니다.
2.	수신 시스템의 변경
    - 예를 들어, 고객 정보를 업데이트하는 메시지가 큐를 통해 전송되었지만, 해당 고객이 이미 삭제된 경우 메시지가 유효하지 않게 됩니다.
    - 또는 컨슈머가 사용하는 데이터베이스의 구조가 변경되어 기존 메시지를 더 이상 해석할 수 없는 경우도 있을 수 있습니다.

이러한 문제들이 발생하면, 실패한 메시지를 DLQ로 이동시켜 원인을 분석하고, 필요하면 재처리할 수 있도록 관리할 수 있습니다.

### DLQ의 동작 방식

DLQ는 일반적인 SQS 큐와 유사하게 동작하지만, 원본 큐에서 처리 실패한 메시지들만을 저장하는 특수한 용도로 사용됩니다.

#### Redrive Policy(재전송 정책)

DLQ로 메시지가 이동하는 기준은 **Redrive Policy(재전송 정책)** 에 의해 결정됩니다.
이 정책에는 메시지가 컨슈머에서 지정된 횟수만큼 실패하면 DLQ로 이동하도록 설정할 수 있습니다.

예를 들어, 재시도 횟수를 3으로 설정한 경우, 같은 메시지가 3번 연속으로 실패하면 자동으로 DLQ로 이동합니다.
이는 일시적인 네트워크 문제나 일회성 장애로 인해 발생하는 메시지 손실을 방지하면서도, 지속적인 실패 메시지를 효과적으로 격리할 수 있도록 합니다.

#### 언제 DLQ를 사용해야 할까?

DLQ는 주로 다음과 같은 상황에서 유용합니다.

1. 비순차적(Unordered) 큐에서 오류 분석이 필요한 경우
    - 메시지 순서가 중요한 경우가 아니라면, DLQ를 활용하여 실패한 메시지를 보관하고 분석한 후, 필요하면 다시 원본 큐로 재전송할 수 있습니다.
2. FIFO 큐에서 순서를 유지하면서 메시지를 관리해야 하는 경우
    - FIFO 큐에서도 DLQ를 사용할 수 있지만, FIFO의 특성상 FIFO 큐 전용 DLQ를 구성해야 합니다.
    - FIFO DLQ를 올바르게 설계하지 않으면 메시지 순서가 깨질 수 있습니다.

#### DLQ를 사용하지 말아야 하는 경우

DLQ가 항상 최선의 선택은 아닙니다. 다음과 같은 경우에는 DLQ 사용이 적절하지 않을 수 있습니다.

1. 무제한 재시도가 필요한 경우
    - 메시지가 특정한 외부 시스템의 가용성에 의존하는 경우, DLQ로 이동시키는 것보다 계속해서 재시도하는 것이 더 적절할 수 있습니다.
    - 예를 들어, 컨슈머가 일정 시간 후 활성화되는 시스템이라면, DLQ로 보내지 않고 계속해서 재처리할 수 있도록 구성하는 것이 더 나을 수도 있습니다.
2. FIFO 큐에서 메시지 순서가 중요한 경우
    - FIFO 큐에서 메시지의 순서가 깨지면 비즈니스 로직이 예상치 못한 방식으로 동작할 수 있습니다.
    - 예를 들어, 동영상 편집 시스템에서 순차적으로 적용해야 하는 편집 명령들이 FIFO 큐에 쌓여있다면, 일부 메시지가 DLQ로 이동하면 순서가 깨져 올바른 편집이 불가능해질 수 있습니다.

#### DLQ 활용 시 고려해야 할 사항

DLQ는 메시지 손실을 방지하고 장애 메시지를 분석하는 데 중요한 역할을 합니다. 하지만, DLQ에 쌓인 메시지를 적절히 관리하지 않으면 결국 새로운 장애 지점이 될 수도 있습니다. 따라서 다음과 같은 방식으로 DLQ를 관리하는 것이 좋습니다.
- DLQ의 메시지를 모니터링하고, 주기적으로 확인
    → AWS CloudWatch와 같은 모니터링 도구를 활용하여 DLQ에 쌓이는 메시지를 지속적으로 추적하는 것이 중요합니다.
- DLQ에서 원본 큐로 메시지를 재전송하는 로직 구현
    → 문제를 해결한 후, SQS의 Redrive to Source Queue 기능을 활용하여 메시지를 다시 원본 큐로 이동시킬 수 있습니다.
- DLQ의 보관 기간(Message Retention Period) 설정
    → 불필요한 메시지가 DLQ에 무한정 쌓이지 않도록, 적절한 보관 기간을 설정하는 것이 중요합니다.


## SQS 메시지 구조와 구성 요소

Amazon SQS에서 메시지는 프로듀서(Producer)가 생성하여 큐에 넣고, 컨슈머(Consumer)가 이를 읽고 처리한 후 삭제하는 방식으로 관리됩니다. SQS는 Standard Queue와 FIFO Queue 두 가지 유형을 제공하며, 각 큐의 특성에 따라 메시지를 다루는 방식이 다를 수 있습니다.

### 메시지의 주요 구성 요소

SQS 메시지는 여러 속성을 포함하며, 이를 통해 메시지의 전달 방식과 처리를 제어할 수 있습니다. 아래는 SQS 메시지의 주요 속성들입니다.

```json
{
  "DelaySeconds": 10,
  "MessageAttributes": {
    "Title": {
      "DataType": "String",
      "StringValue": "제목"
    },
    "Author": {
      "DataType": "String",
      "StringValue": "코드돈"
    },
    "WeeksOn": {
      "DataType": "Number",
      "StringValue": "6"
    },
    "Version": {
      "DataType": "Number",
      "StringValue": "1"
    }
  },
  "MessageSystemAttributes": {
    "AWSTraceHeader": {
      "DataType": "String",
      "StringValue": "Root=1-5e8f59f6-abc123def456"
    }
  },
  "MessageBody": "이 글은 AWS SQS Deep Dive 입니다.",
  "MessageDeduplicationId": "codedon",
  "MessageGroupId": "group-1",
  "QueueUrl": "sqs_queue_url"
}
```

### 메시지 속성 상세 설명
1. DelaySeconds (지연 시간 설정)
    - 메시지를 큐에 추가한 후, 일정 시간 동안 컨슈머가 메시지를 가져가지 못하도록 설정하는 속성입니다.
    - 기본값은 0초이며, 최대 15분(900초)까지 설정할 수 있습니다.
    - FIFO Queue에서는 개별 메시지 단위로 DelaySeconds 설정이 불가능하며, 큐 단위의 Delivery Delay 설정을 사용해야 합니다.
2. MessageAttributes (메시지 속성)
    - 메시지와 함께 추가적인 정보를 전달하는 속성입니다.
      - e.g. 타임스탬프, 지리적 데이터, 서명, ID 값 등
    - 각 속성은 **이름(Name), 데이터 유형(Type), 값(Value)** 으로 구성됩니다.
    - 예를 들어, “Version” 속성을 추가하여 메시지의 버전을 컨슈머가 확인할 수 있도록 할 수 있습니다.
    - 메시지당 최대 10개의 속성을 가질 수 있습니다.
    - 컨슈머는 메시지를 처리할 때, 본문을 직접 읽지 않고 속성 값만 활용할 수도 있습니다.
3. MessageSystemAttributes (시스템 속성)
    - AWS에서 내부적으로 사용하는 속성으로, AWSTraceHeader가 대표적인 예시입니다.
    - X-Ray와 같은 AWS 서비스에서 메시지를 추적할 때 활용됩니다.
    - 시스템 속성은 메시지 크기 제한(256KB)에 포함되지 않습니다.
4. MessageBody (메시지 본문)
    - 메시지의 실제 내용을 포함하며, 문자열 형식(String)으로 저장됩니다.
    - JSON 데이터를 포함하려면, 반드시 **문자열로 변환(Stringify)** 한 후 저장해야 합니다.
5. MessageDeduplicationId (중복 방지 ID) - **FIFO 전용**
    - FIFO Queue에서 중복 메시지 방지를 위해 사용됩니다.
    - 메시지가 생성될 때 자동으로 SHA-256 해시를 이용하여 생성되거나, 프로듀서가 직접 설정할 수 있습니다.
    - 같은 Deduplication ID를 가진 메시지는 5분 이내에 중복된 것으로 간주되어 처리되지 않습니다.
6. MessageGroupId (메시지 그룹 ID) - **FIFO 전용**
    - FIFO Queue에서 메시지의 순서를 보장하기 위해 사용됩니다.
    - 같은 MessageGroupId를 가진 메시지는 반드시 순서대로 처리됩니다.
    - 서로 다른 MessageGroupId를 가진 메시지는 병렬로 처리될 수 있습니다.
7. QueueUrl (큐 URL)
    - 메시지를 보낼 큐의 URL을 지정합니다.
  
# 마무리

지금까지 AWS SQS에 대해 학습한 내용을 정리해 보았습니다.
이론적인 이해를 바탕으로 실제 시스템에 SQS를 도입했고, 현재까지 안정적으로 알림 발송 시스템을 운영하고 있습니다.

물론 실무에서는 예상하지 못한 이슈들이 발생하기 마련이며, 이를 해결하는 과정에서 더욱 깊이 있는 학습이 필요했습니다.
이에 따라 SQS의 도입 과정뿐만 아니라, 운영하면서 경험한 문제들과 해결 과정은 별도로 정리하여 공유하려고 합니다.

SQS는 완전 관리형 서비스(Managed Service) 로 제공되지만, 단순히 사용법만 익히는 것과 내부 동작 방식까지 이해하는 것은 큰 차이가 있습니다.
실제 운영 중 발생할 수 있는 문제를 빠르게 해결하려면, 메시지 큐의 구조와 특성을 충분히 이해하고 활용하는 것이 중요 합니다.

이번 학습 과정이 실무에서 많은 도움이 되었던 만큼, 앞으로도 지속적으로 운영 경험을 쌓아가며 더 나은 시스템을 만들어 나가고자 합니다.


## 레퍼런스
- [AWS SQS 공식문서](https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html)
- [AWS - What is a DLQ](https://aws.amazon.com/what-is/dead-letter-queue/)
