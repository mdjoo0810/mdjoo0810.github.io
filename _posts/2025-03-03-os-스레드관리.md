---
title: OS, 스레드 관리
author: 코드돈
date: 2025-03-03 10:00:00 +0900
categories: [CS, 운영체제]
tags: [cs, os, 운영체제]
---

# 스레드 관리

## 스레드의 개념

프로세스는 자원을 할당 받아 제어하여 작업 즉 목적을 수행한다.
자원과 제어중 제어를 똑때낸게 스레드다.

1개의 프로세스안에 여러개의 스레드가 존재할 수 있다.

### 스레드

![alt text](/_posts/image-7.png)

프로세스는 
제어정보 (Stack Pointer, Program Counter, 상태 등), 지역데이터, Stack 등이 존재하는 스레드 여러개가 존재하고 
리소스 즉 자원은 코드, 전역 데이터, 힙과 같은 공유하는 영역을 의미한다.

- 스레드는 Light Weight Process (LWP) 부름
  - 프로세스틑 자원과 제어를 같이 가지고 있어야하는데 스레드는 제어만 가지고 자원은 공유하기에 가볍다.
- 프로세서 (e.g. CPU) 활용의 기본 단위
- 구성요소
  - Thread ID
  - Register set(PC, SP 등)
  - Stack (i.e. local data)
- 제어 요소 외 코드, 데이터 및 자원들은 프로세스 내 다른 스레드들과 공유
- 전통적 프로세스 = 단일 스레드 프로세스

### 스레드의 장접

- 사용자 응답성
  - 일부 스레드의 처리가 지연되어도, 다른 스레드는 작업을 계속 처리 가능
- 자원 공유 , 경재성
  - 자원을 공유해서 효율성 증가 (커널의 개입을 피할 수 있음)
    - 예시. 프로세스 1, 2가 A 자원을 사용하려 하면 1이 사용하는 동안 2는 대기, 다시 2가 점유하게되면 1이 대기. 이전에 배운 Context Switching 이 일어나게됨.
    - Context Switcing 은 매우 비싼 연산
  - 근데 스레드라면 자원을 공유하고, 동시에 사용할 수 있기에 프로세스의 Context Switching 보다 스위칭할건이 적어 경제적이고 효율적입니다.
- 멀티 프로세서 활용
  - 병렬처리를 통해 성능 향상

### 스레드 사용의 예

만약 프로세서에 스레드가 1개라고 가정하면 게임을 할때 모니터에 화면이 보여지다 마우스를 움직이거나, 키보드를 입력하거나 한다면 화먼은 멈출 것이다.

왜냐하면 이 모든 작업은 I/O 작업이기에 running 중이던 프로세스가 Block 상태로 변하고 마우스를 처리하는 프로세스가 동작하고 이후 마우스 동작이 종료되면 Ready 에 있던 모니터 출력이 프로세스가 동작하기에 각각의 I/O 작업을 처리하는 동안은 다른 작업은 못하게된다.

따라서 이러한 문제를 사용하기 위해 여러개의 스레드를 사용하면 자원을 공유하되 각각의 I/O 작업을 제어하는 것을 스레드가 나누어 작업하기에 동시에 처리가 가능하다.

즉 이전에나온 사용자 응답성이 올라가는 것을 알 수 있다.

## 스레드의 구현

크게 2개로 나눌 수 있음 사용자 수준 스레드, 커널 수준 스레드.

### 사용자 수준 스레드 (User Thread)

- 사용자 영역에 스레드 라이브러리로 구현됨
  - 스레드의 생성, 스케줄링 등 
  - POSIX Threads, Win32 Threads, Java Thread API 등

![alt text](/_posts/image-8.png)


- 커널영역의 스레드와 사용자 영역의 스레드가 일대다 매핑을 하게됨
- 커널은 스레드의 존재를 모름
  - 장점: 커널의 관리를 받지 않음
    - 생성 및 관리의 부하가 적음, 유연한 관리 기능
    - 이식성이 높음
  - 단점: 커널은 프로세스 단위로 자원 할당
    - 하나의 커널 수준 스레드가 block 상태가 되면, 사용자 영역의 모든 스레드가 대기 (single threaded kernel 인 경우)

### 커널 수준 스레드 (Kernel Threads)

![alt text](/_posts/image-9.png)

- OS(Ker) 가 직접 관리
- 장점: 커널이 각 스레드를 개별적으로 관리
  - 프로세스 내 스레드들이 병행수행 가능
    - 하나의 스레드가 block 상태가 되어도, 다른 스레드는 계속 작업 수행 가능
- 단점: 커널 영역에서 스레드의 생성, 관리 수행
  - process 의 스위칭 보다는 비용이 적겠지만 context switching 등 부하가 큼 

### 혼합형 (n:m) 스레드

![alt text](/_posts/image-10.png)

n개의 사용자 수준 스레드 - m 개의 커널 스레드 
- 사용자는 원하는 수만큼 스레드 사용
- 커널 스레드는 자신에게 할당된 하나의 사용자 스레드가 block 상태가 되어도, 다른 스레드 수행 가능
- 효율적이면서도 유연함
